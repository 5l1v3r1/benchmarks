<html>
<style>
.chart rect {
  fill: steelblue;
};

.chart text {
  fill: white;
  font: 10px sans-serif;
  text-anchor: end;
  color: white;
}

.axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.bar {
  fill: steelblue;
}

.x.axis path {
  display: none;
}

.d3-tip {
  line-height: 1;
  font-weight: bold;
  padding: 12px;
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  border-radius: 2px;
}

.d3-tip:after {
  box-sizing: border-box;
  display: inline;
  font-size: 10px;
  width: 100%;
  line-height: 1;
  color: rgba(0, 0, 0, 0.8);
  content: "\25BC";
  position: absolute;
  text-align: center;
}

.d3-tip.n:after {
  margin: -1px 0 0 0;
  top: 100%;
  left: 0;
}
</style>

<pre id="output">Loading...</pre>
<pre id="tables">Tables: </pre>

<select id="method_select" onchange="methodSelect()">
  <option>Loading...</option>
</select>

<select id="param_select" onchange="paramSelect()">
  <option>Loading...</option>
</select>

<div id="boxes"></div>

<script src='js/sql.js'></script>
<script src='js/d3.min.js'></script>
<script src='js/d3.tip.js'></script>
<script>
  // Load benchmark.db.  Later, we will do something cool with it, once I figure
  // out how.
  var xhr = new XMLHttpRequest();
  xhr.open('GET', 'benchmark.db', true);
  xhr.responseType = 'arraybuffer';
  var db = new SQL.Database();

  // "Global" variables.
  var libraries; // Full list of libraries for this method and parameters.
  var active_libraries; // List of active libraries for this method and parameters.
  var datasets; // Full list of datasets for this method and parameters.
  var active_datasets; // Full list of active datasets for this method and parameters.
  var method_name; // Name of currently active method;
  var param_name; // Name of currently active parameters.
  var results; // Results for current method and parameters.

  // Static bindings of library names to colors.
  var color = d3.scale.ordinal().range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);

  function listMethods()
  {
    var methods = db.exec("SELECT DISTINCT name FROM methods ORDER BY name;");
    var method_select_box = document.getElementById("method_select");

    // Remove old things from the list box.
    for(i = method_select_box.options.length - 1; i >= 0; i--)
    {
      method_select_box.options[i] = null;
    }

    // Put new things in the list box.
    for(i = 0; i < methods[0].values.length; i++)
    {
      var new_option = document.createElement("option");
      new_option.text = methods[0].values[i];
      method_select_box.add(new_option);
    }
    method_select_box.selectedIndex = -1;
  }

  function methodSelect()
  {
    // Extract the name of the method we selected.
    var method_select_box = document.getElementById("method_select");
    method_name = method_select_box.options[method_select_box.selectedIndex].text; // At higher scope.

    // Now get all of the possible parameters for that function.
    var sqlstr = "SELECT methods.parameters, results.libary_id FROM methods, results WHERE methods.name == '" + method_name + "' AND methods.id == results.method_id GROUP BY methods.parameters;";
    var params = db.exec(sqlstr);

    // Loop through results and fill the second list box.
    var param_select_box = document.getElementById("param_select");

    // Remove old things.
    for(i = param_select_box.options.length - 1; i >= 0; i--)
    {
      param_select_box.options[i] = null;
    }

    // Put in the new options.
    for(i = 0; i < params[0].values.length; i++)
    {
      var new_option = document.createElement("option");
      if(params[0].values[i][0])
      {
        new_option.text = params[0].values[i][0] + " (" + params[0].values[i][1] + " libraries)";
      }
      else
      {
        new_option.text = "[no parameters] (" + params[0].values[i][1] + " libraries)";
      }
      param_select_box.add(new_option);
    }
    param_select_box.selectedIndex = -1;
  }

  function paramSelect()
  {
    // The user has selected a library and parameters.  Now we need to generate
    // a chart for all applicable datasets.
    var method_select_box = document.getElementById("method_select");
    var method_name = method_select_box.options[method_select_box.selectedIndex].text;
    var param_select_box = document.getElementById("param_select");
    var param_name_full = param_select_box.options[param_select_box.selectedIndex].text;
    // Parse out actual parameters.
    param_name = param_name_full.split("(")[0].replace(/^\s+|\s+$/g, ''); // At higher scope.

    // Given a method name and parameters, query the SQLite database for all of
    // the runs.
    var sqlstr = "SELECT DISTINCT results.time, results.var, libraries.id, libraries.name, datasets.name, datasets.id " +
        "FROM results, datasets, methods, libraries WHERE results.dataset_id == datasets.id AND results.method_id == methods.id " +
        "AND methods.name == '" + method_name + "' AND methods.parameters == '" + param_name + "' AND libraries.id == results.libary_id " +
        "GROUP BY datasets.id, libraries.id;";
    results = db.exec(sqlstr);

    // Obtain unique list of datasets.
    datasets = results[0].values.map(function(d) { return d[4]; }).reduce(function(p, c) { if(p.indexOf(c) < 0) p.push(c); return p; }, []);
    // Obtain unique list of libraries.
    libraries = results[0].values.map(function(d) { return d[3]; }).reduce(function(p, c) { if(p.indexOf(c) < 0) p.push(c); return p; }, []);

    // By default, everything is active.
    active_datasets = {};
    for(i = 0; i < datasets.length; i++)
    {
      active_datasets[datasets[i]] = true;
    }

    active_libraries = {};
    for(i = 0; i < libraries.length; i++)
    {
      active_libraries[libraries[i]] = true;
    }

    clearChart();
    buildRuntimeComparisonChart();
  }

  function clearChart()
  {
    d3.select("svg").remove();
    d3.selectAll(".d3-tip").remove();
  }

  function buildRuntimeComparisonChart()
  {
    // Basic chart parameters.
    var width = 800; // This should be parameterizable...
    var height = 600; // This should be parameterizable...
    var margin = { top: 20, right: 20, bottom: 120, left: 40 };

    // Set up scales.
    var group_scale = d3.scale.ordinal()
        .domain(datasets.map(function(d) { return d; }).reduce(function(p, c) { if(active_datasets[c] == true) { p.push(c); } return p; }, []))
        .rangeRoundBands([0, width], .1);
    var library_scale = d3.scale.ordinal()
        .domain(libraries.map(function(d) { return d; }).reduce(function(p, c) { if(active_libraries[c] == true) { p.push(c); } return p; }, []))
        .rangeRoundBands([0, group_scale.rangeBand()]);
    var max_runtime = d3.max(results[0].values, function(d) { if(active_datasets[d[4]] == false) { return 0; } else if(d[0] == ">9000") { return 0; } else if(d[0] == "failure") { return 0; } else { return d[0]; } });

    var runtime_scale = d3.scale.linear()
        .domain([0, max_runtime])
        .range([height, 0]);

    // Set up axes.
    var xAxis = d3.svg.axis().scale(group_scale).orient("bottom");
    var yAxis = d3.svg.axis().scale(runtime_scale).orient("left").tickFormat(d3.format(".2s"));

    // Create svg object.
    var svg = d3.select("body").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Add x axis.
    svg.append("g").attr("id", "xaxis")
      .attr("class", "x axis")
      .attr("transform", "translate(0, " + height + ")")
      .call(xAxis)
      .selectAll("text")
          .style("text-anchor", "end")
          .attr("dx", "-.8em")
          .attr("dy", ".15em")
          .attr("transform", "rotate(-65)");

    // Add y axis.
    svg.append("g")
      .attr("class", "y axis")
      .call(yAxis)
      .append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("dy", ".71em")
      .style("text-anchor", "end")
      .text("Runtime (s)");

    // Create groups.
    var group = svg.selectAll(".group")
      .data(datasets.map(function(d) { return d; }).reduce(function(p, c) { if(active_datasets[c] == true) { p.push(c); } return p; }, []))
      .enter().append("g")
      .attr("class", "g")
      .attr("transform", function(d) { return "translate(" + group_scale(d) + ", 0)"; });

    // Create tooltips.
    var tip = d3.tip()
        .attr("class", "d3-tip")
        .offset([-10, 0])
        .html(function(d) {
            var runtime = d[0];
            if (d[0] != ">9000" && d[0] != "failure") { runtime = d[0].toFixed(1); }
            return "<strong>Runtime for " + d[3] + ":</strong> <span style='color:yellow'>" + runtime + "s</span>"; });

    svg.call(tip);

    // Add all of the data points.
    group.selectAll("rect")
      .data(function(d) // For a given dataset d, collect all of the data points for that dataset.
          {
            var ret = [];
            for(i = 0; i < results[0].values.length; i++)
            {
              if(results[0].values[i][4] == d && active_libraries[results[0].values[i][3]] == true) { ret.push(results[0].values[i]); }
            }
            console.log(JSON.stringify(ret));
            return ret;
          })
      .enter().append("rect")
        .attr("width", library_scale.rangeBand())
        .attr("x", function(d) { return library_scale(d[3]); })
        .attr("y", function(d) { if(d[0] == ">9000") { return runtime_scale(max_runtime); } else if(d[0] == "failure") { return runtime_scale(0); } else { return runtime_scale(d[0]); } })
        .attr("height", function(d) { var subh; if(d[0] == ">9000") { subh = runtime_scale(max_runtime); } else if(d[0] == "failure") { subh = runtime_scale(0); } else { subh = runtime_scale(d[0]); } return height - subh; })
        .style("fill", function(d) { return color(d[3]); })
        .on('mouseover', tip.show)
        .on('mouseout', tip.hide);

    // Add a horizontal legend at the bottom.
    console.log(JSON.stringify(libraries));
    console.log(JSON.stringify(active_libraries));
    var legend = svg.selectAll(".legend")
        .data(libraries) // All libraries are used here.
        .enter().append("g")
        .attr("class", "legend")
        .attr("transform", function(d, i) { return "translate(" + i * 50 + ",0)"; });

    legend.append("rect")
        .attr("x", function(d, i) { return i * 50 - 2; })
        .attr("y", height + 48)
        .attr("width", 75)
        .attr("height", 22)
        .attr("fill", function(d) { if(active_libraries[d]) { return "none"; } else { return "#888888" } })
        .on('click', function(d, i) { toggleLibrary(d); });

    legend.append("rect")
        .attr("x", function(d, i) { return i * 50; })
        .attr("y", height + 50)
        .attr("width", 18)
        .attr("height", 18)
        .style("fill", color)
        .on('click', function(d, i) { toggleLibrary(d); });

    legend.append("text")
        .attr("x", function(d, i) { return i * 50 + 25; })
        .attr("y", height + 50)
        .attr("dy", ".85em")
        .style("text-anchor", "start")
        .style("fill", "#000000")
        .text(function(d) { return d; })
        .on('click', function(d, i) { toggleLibrary(d); });

    // Allow clicking on the dataset.
    d3.select('#xaxis')
        .selectAll('.tick')
        .on('click', function(d, i) { toggleDataset(d); });

    // Add another horizontal legend for the datasets which aren't in use.
    var dataset_legend = svg.selectAll(".datalegend")
        .data(datasets.map(function(d) { return d; }).reduce(function(p, c) { if(active_datasets[c] == false) { p.push(c); } return p; }, []))
        .enter().append("g")
        .attr("class", "datalegend")
        .attr("transform", function(d, i) { return "translate(" + i * 50 + ",0)"; });

/*    dataset_legend.append("rect")
        .attr("x", function(d, i) { return i * 50; })
        .attr("y", height + 100)
        .attr("width", 18)
        .attr("height", 18)
        .style("fill", color)
        .on('click', function(d, i) { toggleDataset(d); });*/

    dataset_legend.append("text")
        .attr("x", function(d, i) { return i * 50 + 25; })
        .attr("y", height + 100)
        .attr("dy", ".85em")
        .style("text-anchor", "start")
        .style("fill", "#000000")
        .text(function(d) { return d; })
        .on('click', function(d, i) { toggleDataset(d); });
  }

  function toggleLibrary(library)
  {
    console.log("toggle library " + library);
    active_libraries[library] = !active_libraries[library];

    clearChart();
    buildRuntimeComparisonChart();
  }

  function toggleDataset(dataset)
  {
    console.log("toggle dataset " + dataset);
    active_datasets[dataset] = !active_datasets[dataset];

    clearChart();
    buildRuntimeComparisonChart();
  }

  // Query for the list of libraries, and create a mapping from library names to
  // colors for use by the graphs.
  function createColorMapping()
  {
    var librarylist = db.exec("SELECT libraries.name FROM libraries;");

    libraries = librarylist[0].values.map(function(d) { return d[0]; }).reduce(function(p, c) { if(p.indexOf(c) < 0) p.push(c); return p; }, []);
    color.domain(libraries);
  }

  xhr.onload = function(e) {
    var uInt8Array = new Uint8Array(this.response);
    db = new SQL.Database(uInt8Array);

    createColorMapping();
    listMethods();
  };

  document.getElementById("output").innerHTML = "Loading while farting.";
  xhr.send();
  document.getElementById("output").innerHTML = "Loading while farted.";

</script>
</body>
</html>
